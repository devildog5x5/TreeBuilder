# Tree Builder 3.4 API & Component Reference

## Overview
Tree Builder 3.4 is a Visual Basic 6 tool that automates building and populating NDS/eDirectory trees by generating LDIF files and driving Novell's `ice.exe`/`ldapmodify` command-line utilities. The project configuration captures that it can add/delete/modify directory entries, import/export LDIF, and optionally create matching home directories for load testing environments.
```16:33:TreeBldrv3.vbp
Startup="ConversionTool"
Title="TreeBuilder34"
Description="Tree Builder version 3.4 is an ICE.EXE interface tool that assists the user in creating NDS objects via LDAP."
VersionComments="...It creates an LDIF file that that is then imported via ICE.EXE using a batch file processs. It also has the ability to create user home directories."
```

## External Dependencies & Shared Utilities
Tree Builder relies on a common set of Win32 API calls and helper functions that appear across multiple forms:
- `OpenProcess`, `GetExitCodeProcess`, and `Sleep` are used to monitor long-running shell jobs (`ice.exe`, `ldapmodify`).
- `ShellExecute` opens generated files in Notepad or launches online docs.
- `BrowseForFolder`, `cmnDialog.ShowOpen`, and `DeleteFile` (declared elsewhere in the VB6 project) provide file-system UI and cleanup.
- `DoesFileExist.FileExists` exposes a reusable way to block until expected files (LDIF, logs, imports) exist.

### File existence helper (`DoesFileExist.bas`)
`FileExists` wraps the Win32 `FindFirstFile` API and is called throughout the forms (for example, before parsing import files or before tailing `ice.log`).
```4:41:DoesFileExist.bas
Public Const INVALID_HANDLE_VALUE = -1
Public Const MAX_PATH = 260
...
Public Function FileExists(sSource As String) As Boolean
  Dim WFD As WIN32_FIND_DATA
  Dim hFile As Long
  hFile = FindFirstFile(sSource, WFD)
  FileExists = hFile <> INVALID_HANDLE_VALUE
  Call FindClose(hFile)
End Function
```

A simple usage example is already included in `FileExists.bas` and can be re-used anywhere in the project:
```53:56:FileExists.bas
'Private Sub Command1_Click()
'    MsgBox FileExists("c:\win\system\comctl32.dll")
'End Sub
```

## UI Components and Public Workflows
Tree Builder ships with multiple VB6 forms. The main operator-facing experience lives in `frmOptions` (exported as `frmOptions2.frm` in this snapshot), while the smaller `ConversionTool`, `ICE`, and `QuickSTart` forms cover LDIF conversion, log viewing, and onboarding tips.

### `frmOptions` (Tree Builder UX)
`frmOptions` is the dashboard that captures server connection settings, user-set templates, tree settings, and execution toggles. Nearly every control ultimately feeds the central `CmdUpdate_Click` workflow.

#### Primary workflow: `CmdUpdate_Click`
The update button gathers every field on the form, writes LDIF content, optionally executes `ice.exe` or `ldapmodify`, and can also provision home directories.
```3656:3765:frmOptions2.frm
Private Sub CmdUpdate_Click()
   Dim RICEBatch As String
   Dim FileOut As String
   ...
   RICEBatch = Text5.Text
   FileOut = Text6.Text
   filein = Text7.Text
   servername = Text8.Text
   domainname = Text9.Text
   beginval = 1
   endval = Val(Combo2.Text)
   ...
   CustLDIF = Text30.Text
```
Key stages inside this routine:
1. **LDIF generation & optional tree scaffolding** – when `CustomCheck` is off, a new LDIF file is opened and populated with optional country (`c=`), organization (`o=`), and up to 36 organizational units before any users are emitted. `SkipTreeCreateCheck` lets you bypass this block.
```3883:3945:frmOptions2.frm
MyVar = MsgBox("Files are being written", 0, "Writting Files.")
Open FileOut For Output As #1
Print #1, "#This file generated by Novell's Tree Builder Version 3.3 ..."
If SkipTreeCreateCheck = 0 Then GoTo BypassTree
...
Print #1, "dn: c=" + CCont
Print #1, "changetype: " + CType
Print #1, "objectClass: country"
...
Print #1, "dn: o=" + Org + ",c=" + CCont
Print #1, "objectClass: organization"
```
2. **User generation loops** – for each enabled user set (up to four), the routine emits per-user LDIF entries that honor the selected context, attributes, password strategy, and optional domain suffix. Conditional branches handle add/delete/modify as well as `NoPwd`/`Make passwords match username` options.
```4374:4415:frmOptions2.frm
For i = beginval To endval
  If UserSetOneCheck = 0 Then GoTo Step10
  Print #1, "dn: cn=" + userid1 + Format(i) + ...
  Print #1, "changetype: " + CType
  If ver = "NDS 7" Then Print #1, "objectclass: person"
  If ver = "NDS 8" Then Print #1, "uid: " + userid1 + Format(i)
  ...
  If passwordm = "Yes" Then Print #1, "userpassword: " + userid1 + Format(i) Else Print #1, "userpassword: " + password1
  If ver = "NDS 8" Then Print #1, "ndsHomeDirectory: " + homedir + "\" + userid1 + Format(i)
Next i
```
3. **ICE/LDAP integration** – after writing the LDIF, the routine builds a batch command for `ice.exe` (for add/delete/retrieve) or `ldapmodify` (for modify mode). Flags such as `StopOnErrCheck`, `CheckWriteOnly`, `RetrieveTreeCheck`, and `CustomCheck` adjust which switches are emitted.
```4770:4839:frmOptions2.frm
Sice = "ice" + " "
Source_Sw = "-S" + " "
...
If StopOnErrCheck = 0 Then Print #2, Sice + Source_Sw + LDIF_Sw + F_Sw + FOut + StopOnErr + Destination_Sw + LDAP_Sw + ...
If RetrieveTreeCheck = 1 Then Print #2, Sice + Source_Sw + LDAP_Sw + IP_Sw + IP + ... + Destination_Sw + LDIF_Sw + F_Sw + FIn
...
If CheckWriteOnly = 1 Then GoTo JumpExe
ICE.Show 0
JobToDo = RICEBatch
Shell32Bit JobToDo
```
4. **Home directory provisioning** – when `UserHomeCheck` is enabled, `CmdUpdate_Click` (re)creates per-user directories beneath `Text403` and drops a user-identifying file (default `index.html`) in each `Text404` subfolder.
```4845:4875:frmOptions2.frm
beginval1 = 1
endval1 = Val(Combo2.Text)
If UserHomeCheck = 0 Then GoTo Step161
If (fso.FolderExists(MyPath)) Then GoTo Step1000 Else MkDir MyPath
...
For j = beginval1 To endval1
   If (fso.FolderExists(MyPath + userid1 + Format(j))) Then GoTo CStep1 Else MkDir MyPath + userid1 + Format(j)
   ChDir UHomeDir
   Open UHomeFile For Output As #2
   Print #2, userid1 + Format(j)
   ChDir "cd ..\.."
Next j
```

#### Operation toggles & supporting actions
Several lightweight event handlers constrain valid combinations of options and provide reusable UI wrappers:
- `CustomCheck_Click`, `CheckModify_Click`, `CheckAdd_Click`, `CheckDel_Click`, `RetrieveTreeCheck_Click`, `SkipTreeCreateCheck_Click`, `AppDomCheck1_Click`, and `CustContCheck_Click` enforce mutually exclusive states (for example, selecting "Use Custom LDIF" automatically unchecks add/modify/delete).
- `SelectAllUserSetCheck_Click` bulk-selects user sets; turning it off clears the downstream check boxes.
- File/dir pickers (`CmdBrowse1`–`CmdBrowse6` & `CfgBrowse`) all share the same pattern: seed the common dialog with the current text box value, show the picker, then restore defaults if users cancel.
```2248:3435:frmOptions2.frm
Private Sub CustomCheck_Click()
  If CustomCheck = 1 Then RetrieveTreeCheck = 0
  If CustomCheck = 1 Then CheckAdd = 0
  ...
End Sub
...
Private Sub CmdBrowse1_Click()
  cmnDialog.FileName = Text4.Text
  cmnDialog.ShowOpen
  Text4.Text = cmnDialog.FileName
  If Text4.Text = "" Then Text4.Text = "Rootcert.der"
End Sub
...
Private Sub CmdBrowse6_Click()
  getdir = Text403.Text
  getdir = BrowseForFolder(Me, "Select A Directory to Create User Home Directories in", getdir)
  If Len(getdir) = 0 Then Exit Sub
  Text403.Text = getdir
End Sub
```

#### Viewing & cleanup commands
Tree Builder exposes quick ways to inspect generated artifacts and to clean them up between runs.
```3474:3499:frmOptions2.frm
Private Sub cmdViewExp_Click()
  FileOut = Text6.Text
  RetVal = ShellExecute(0, "open", "notepad", FileOut, "", SW_SHOW)
End Sub
...
Private Sub cmdViewImp_Click()
  filein = Text7.Text
  RetVal = ShellExecute(0, "open", "notepad", filein, "", SW_SHOW)
End Sub
```
```3445:3456:frmOptions2.frm
Private Sub cmdClean_Click()
   RICEBatch = Text5.Text
   FileOut = Text6.Text
   filein = Text7.Text
   RetVal = DeleteFile(RICEBatch)
   RetVal = DeleteFile(FileOut)
   RetVal = DeleteFile(filein)
   RetVal = DeleteFile("ice.log")
End Sub
```

#### Configuration lifecycle (read/save/reset)
Operators can persist every control value to a config file, restore defaults, or import a saved set. The read path is intentionally linear—values are read back in the exact order they were written, so custom configs must keep the same line ordering.
```2262:2307:frmOptions2.frm
Private Sub ReadConfig_Click()
    ConfigFile = Text32.Text
    Do While FileExists(ConfigFile) = "False"
        DoEvents: Sleep 100
    Loop
    Open ConfigFile For Input As #File2
      Line Input #File2, File_Data
      Text1.Text = CVar(File_Data)
      Line Input #File2, File_Data
      Combo1.Text = CVar(File_Data)
      ...
```
```3042:3070:frmOptions2.frm
Private Sub ResetAll_Click()
   Text1.Text = "255.255.255.255"
   Combo1.Text = "389"
   AnonCheck = 0
   RetrieveTreeCheck = 0
   Text2.Text = "cn=admin,o=novell"
   Text3.Text = "test"
   Text14.Text = "o=Novell"
   Text31.Text = "sub"
   Combo2.Text = "1"
   Combo6.Text = "NDS 8"
   CheckAdd = 1
   CheckDel = 0
   ... 'continues resetting every user-set field
End Sub
```
(Saving simply writes all of those fields back out in order.)

#### Process harness: `Shell32Bit`
`Shell32Bit` is Tree Builder's blocking process runner. It launches the prepared batch file, tails `ice.log` into the `ICE` form, and prompts the operator when the external command finishes.
```5019:5057:frmOptions2.frm
Sub Shell32Bit(ByVal JobToDo As String)
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell(JobToDo, 0))
    Do
       GetExitCodeProcess hProcess, RetVal
       DoEvents: Sleep 1000
       Do While FileExists(WPath & IceLog) = "False"
           Sleep 1000
       Loop
       Open (WPath & IceLog) For Input As #File2
       ICE.Text1.Text = ""
       While Not EOF(File2)
           Line Input #File2, File_Data
           ICE.Text1.Text = ICE.Text1.Text & File_Data & Chr(13) & Chr(10)
       Wend
       Close #File2
    Loop While RetVal = STILL_ACTIVE
    MyVar = MsgBox("The Update is Complete...", vbOKCancel, "Update Complete!")
    If MyVar = vbOK Then Unload ICE
End Sub
```

#### Usage example: provisioning a test tree
1. Click **Reset All** to start from known defaults (see `ResetAll_Click`).
2. Adjust LDAP host/port (`Text1`, `Combo1`), bind DN/password (`Text2`, `Text3`), and base DN (`Text14`).
3. Populate the user-set templates (names, titles, passwords) or import a saved config.
4. Leave **Add** checked, optionally keep **Create Tree/Container Information** enabled to emit the OU structure described by the `OrgU*` fields.
5. Click **Run Update**. `CmdUpdate_Click` writes `Text6` (export LDIF), spawns `ice.exe` using the assembled switches, and streams `ice.log` into the ICE form.
6. If **Create User Home Directories** is checked, the directories and marker files appear beneath `Text403`/`Text404` immediately after the ICE run completes.

### `ConversionTool` (parseit.Frm)
This form (set as the VB6 startup object) converts comma-/custom-delimited lists of usernames into LDIF entries or imports a structured text file where each token is prefixed (`USER0`, `FIRST0`, `LAST0`). It reuses the same attribute template controls seen on `frmOptions`.

#### Manual text parsing path
When **Convert** is clicked and the "Use external import file" checkbox is off, the control parses the `Text1` multiline list, normalizes separators according to `Text2`, and writes LDIF entries using the UI defaults.
```444:525:parseit.Frm
Private Sub Command1_Click()
    domainname = Domain.Text
    context = UserContext.Text
    ...
    If CheckNewImportFile = 1 Then GoTo FParser
    Open TextExportFile For Output As #1
    Print #1, "#This LDIF file was generated..."
    P$ = Text2.Text
    A$ = Text1.Text
    For i = 2 To Len(P$)
        k = InStr(A$, Mid$(P$, i, 1))
        Do While k
            Mid$(A$, k, 1) = Left$(P$, 1)
            k = InStr(A$, Mid$(P$, i, 1))
        Loop
    Next
    Do While Len(A$)
        k = InStr(A$, Left$(P$, 1))
        ...
        Print #1, "dn: cn=" + B$ + context
        Print #1, "mail: " + B$ + "@" + domainname
        Print #1, "givenName: " + givename1
        ...
    Loop
```

#### External file parsing path
Checking **Use external import file** jumps into `FParser`, prompting for a file when the current path does not exist and then processing each line. Tokens starting with `USER0`, `FIRST0`, or `LAST0` are mapped to their respective attributes before the LDIF payload is written.
```534:610:parseit.Frm
FParser:
    If CheckNewImportFile = 0 Then GoTo FParserEnd
    Open TextExportFile For Output As #1
    ...
    If FileExists(TextImportFile) = "False" Then cmnDialog.ShowOpen
    TextImportBox.Text = cmnDialog.FileName
    ...
    Do While Len(A$)
        k = InStr(A$, Left$(P$, 1))
        If B$ Like "USER0*" Then User1 = B$
        If B$ Like "FIRST0*" Then First1 = B$
        If B$ Like "LAST0*" Then Last1 = B$
        ...
        Print #1, "dn: cn=" + B$ + context
        Print #1, "givenName: " + B$
        Print #1, "sn: " + B$
```

#### Utility commands
Buttons on this form provide the same browse/view affordances as `frmOptions`, using `ShellExecute` to open files in Notepad.
```657:683:parseit.Frm
Private Sub BrowseExportTFile_Click()
    cmnDialog.FileName = TextExportBox.Text
    cmnDialog.ShowOpen
    TextExportBox.Text = cmnDialog.FileName
End Sub
...
Private Sub ViewTextFileExp_Click()
    filein = TextExportBox.Text
    RetVal = ShellExecute(0, "open", "notepad", filein, "", SW_SHOW)
End Sub
```

#### Usage examples
- **Convert inline list**: paste comma-separated usernames into `Text1`, set `UserContext`, `Domain`, `GivenName`, etc., leave the "import file" checkbox cleared, and click **Convert**. The LDIF written to `TextExportBox` mirrors the attribute template shown in `Command1_Click`.
- **Convert annotated file**: check the import box, click **Convert**, choose a text file built from `USER0`, `FIRST0`, `LAST0` tokens, and wait for `FileExists` to confirm the file path. The output file is re-seeded with the standard header and populated directly from the file contents.

### `ICE` form
`ICE.frm` only contains a multiline textbox (`Text1`) that displays `ice.log`. All interactions flow through `Shell32Bit`, which clears and repopulates the text box every time the external process writes to disk (see the `Shell32Bit` snippet above).

### `QuickSTart` form
A simple modal explaining the high-level setup steps; it closes itself via `UnloadQS_Click`.
```166:173:QuickSTart.frm
Private Sub UnloadQS_Click()
Unload Me
End Sub
```

## Putting it all together
- **End-to-end Add run**: configure connection/auth settings, verify `Text6`/`Text7` paths, keep **Add** checked, optionally enable **Create User Home Directories**, then press **Run Update**. Watch the ICE form to confirm success; inspect the LDIF or batch using the "View" buttons; re-run with **Delete** or **Modify** after toggling the respective checkboxes.
- **Standalone LDIF generation**: check **Only Write Files (Do not execute ICE)** to have `CmdUpdate_Click` stop after writing the LDIF, leaving the batch file untouched until you manually run it.
- **Tree retrieval**: select **Retrieve Tree Information** to flip ICE into LDAP→LDIF mode (note how `CmdUpdate_Click` emits the `-b` base DN, `-c` search scope, and destination file switches in that branch), then optionally open the resulting import file via **View Import File**.
- **Custom LDIF runs**: check **Use This Custom LDIF File** to bypass file generation entirely. `CmdUpdate_Click` will still build a batch file pointing to `Text30`, letting you execute a hand-crafted LDIF with the same connection settings and logging pipeline.

Refer to the cited code blocks whenever you need to adjust or extend these workflows; every public-facing control eventually funnels through the snippets highlighted above.
